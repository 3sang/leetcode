
## 212. 单词搜索Ⅱ
### Tire前缀树、回溯算法。
依然不会做的一天
***

###  **给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。** 

**单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。** 

**示例 1:**

![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)
```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```
# 
**示例 2:**

![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)
```
输入：board = [["a","b"],["c","d"]], words = ["abcb"]
输出：[]
```
--- 

### **分析时间：**

[题解题解题解](https://leetcode-cn.com/problems/word-search-ii/solution/bao-li-hui-su-jian-zhi-by-xiaoranzife-3n3b/)

[这个题解里抄来的](https://leetcode-cn.com/problems/word-search-ii/solution/javascript-qian-zhui-shu-dfssou-suo-by-b-tigw/)：

这个题其实看到的首先的思路就是回溯，从 board[0][0] 开始，每一个字母都按照四个方向进行查找，如果查找到了一个 words 里面的单词就放到结果数组里面。然后再开始下一次的查找。

在回溯的思路确定的前提下，先考虑一下有没有可能优化的点。

比如说对于两个单词：oath 和 oathf，这两个单词都有同样的前缀部分 oath，那么是否可以考虑在找到 oath 以后，就不必要再重头开始找，而是直接利用这个前缀进行下一步的查找，同样，如果当前查找到的部分在已知的前缀集合中不存在，那么就没必要再往下找了。

上面保存前缀的数据结构叫做**前缀树(Trie 树， 字典树)，是一种多叉树，针对这个题只考虑每个节点都是字母的情况。**


> 前缀树有三个特点：
>- 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
>- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串(也就是路径)
>- 每个节点的所有子节点包含的字符都不相同。

打印出来的["oath","pea","eat","rain"]的前缀树结构

```
TrieNode {
 isWord: false,
  value: undefined,
  children: Map(4) {
    'o' => TrieNode { isWord: false, value: 'o', children: [Map] },
    'p' => TrieNode { isWord: false, value: 'p', children: [Map] },
    'e' => TrieNode { isWord: false, value: 'e', children: [Map] },
    'r' => TrieNode { isWord: false, value: 'r', children: [Map] }
  }
}
```



--- 

#
### **解法1：构造前缀树遍历**

```
/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
    const m = board.length;
    const n = board[0].length;
    const res = [];
    const direction = [
        [-1, 0],    // 上
        [1, 0],     // 下
        [0, -1],    // 左
        [0, 1]      // 右
    ];
    const root = createTrie(words);

    const dfs = function(x, y, node) {
        if(x < 0 || y < 0 || x >= m || y >= n) {
            return;
        }
        const char = board[x][y];
        node = node.children.get(char);
        if(!node || board[x][y] === '') {
            return;
        }
        if(node.isWord) {
            res.push(node.word);
            node.isWord = false;
            node.word = undefined;
        }
        board[x][y] = '';
        for(let [dx, dy] of direction) {
            dfs(x + dx, y + dy, node);
        }
        board[x][y] = char;
    }

    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            dfs(i, j, root);
        }
    }
    return res;
};

// 构建前缀树
const createTrie = function(words) {
    class TrieNode {
        constructor(isWord, value, children) {
            this.isWord = isWord;
            this.value = value;
            this.children = children;
        }
    }

    // 前缀树的根节点
    const root = new TrieNode(false, undefined, new Map());
    let node = root;

    const createTrieHelper = function(word) {
        for(let i = 0; i < word.length; i++) {
            const char = word[i];
            let newNode;
            if(node.children && !node.children.has(char)) {
                newNode = new TrieNode(i === word.length - 1, char, new Map());
                node.children.set(char, newNode);
            } else {
                newNode = node.children.get(char);
                if(i === word.length - 1) {
                    newNode.isWord = true;
                }
            }
            if(newNode.isWord && !newNode.word) {
                newNode.word = word;
            }
            node = newNode;
        }

        // 每次创建完一个分支，将 node 重新指向根节点，方便进行对下一个单词的创建
        node = root;
    }

    for(const word of words) {
        createTrieHelper(word);
    }

    return root;
};

```
